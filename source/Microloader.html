<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">// here, the extra check for window['Ext'] is needed for use with cmd-test
// code injection.  we need to make that this file will sync up with page global
// scope to avoid duplicate Ext.Boot state.  That check is after the initial Ext check
// to allow the sandboxing template to inject an appropriate Ext var and prevent the
// global detection.
var Ext = Ext || window['Ext'] || {};


//&lt;editor-fold desc=&quot;Microloader&quot;&gt;
<span id='Ext-Microloader'>/**
</span> * @class Ext.Microloader
 * @private
 * @singleton
 */
Ext.Microloader = Ext.Microloader || (function () {
    var Boot = Ext.Boot,
    //&lt;debug&gt;
        _debug = function (message) {
            //console.log(message);
        },
    //&lt;/debug&gt;
        _warn = function (message) {
            console.log(&quot;[WARN] &quot; + message);
        },
        _privatePrefix = '_ext:' + location.pathname,

<span id='Ext-Microloader-method-getStorageKey'>        /**
</span>         * @method getStorageKey
         * The Following combination is used to create isolated local storage keys
         * '_ext' is used to scope all the local storage keys that we internally by Ext
         * 'location.pathname' is used to force each assets to cache by an absolute URL (/build/MyApp) (dev vs prod)
         * 'url' is used to force each asset to cache relative to the page (app.json vs resources/app.css)
         * 'profileId' is used to differentiate the builds of an application (neptune vs crisp)
         * 'Microloader.appId' is unique to the application and will differentiate apps on the same host (dev mode running app watch against multiple apps)
         */
        getStorageKey = function(url, profileId) {
            return  _privatePrefix + url + '-' + (profileId ? profileId + '-' : '') + Microloader.appId;
        },
        postProcessor, _storage;

    try {
        _storage = window['localStorage'];
    } catch(ex) {
        // ignore
    }

    var _cache = window['applicationCache'],
        // Local Storage Controller
        LocalStorage = {
            clearAllPrivate: function(manifest) {
                if(_storage) {

                    //Remove the entry for the manifest first
                    _storage.removeItem(manifest.key);

                    var i, key,
                        removeKeys = [],
                        suffix = manifest.profile + '-' + Microloader.appId,
                        ln = _storage.length;
                    for (i = 0; i &lt; ln; i++) {
                        key = _storage.key(i);
                        // If key starts with the private key and the suffix is present we can clear this entry
                        if (key.indexOf(_privatePrefix) === 0 &amp;&amp; key.indexOf(suffix) !== -1) {
                            removeKeys.push(key);
                        }
                    }

                    for(i in removeKeys) {
                        //&lt;debug&gt;
                        _debug(&quot;Removing &quot;+ removeKeys[i] + &quot; from Local Storage&quot;);
                        //&lt;/debug&gt;
                        _storage.removeItem(removeKeys[i]);
                    }
                }
            },
<span id='Ext-Microloader-method-retrieveAsset'>            /**
</span>             * @private
             */
            retrieveAsset: function (key) {
                try {
                    return _storage.getItem(key);
                }
                catch (e) {
                    // Private browsing mode
                    return null;
                }
            },

            setAsset: function(key, content) {
                try {
                    if (content === null || content == '') {
                        _storage.removeItem(key);
                    } else {
                        _storage.setItem(key, content);
                    }
                }
                catch (e) {
                    if (_storage &amp;&amp; e.code == e.QUOTA_EXCEEDED_ERR) {
                        //&lt;debug&gt;
                        _warn(&quot;LocalStorage Quota exceeded, cannot store &quot; + key + &quot; locally&quot;);
                        //&lt;/debug&gt;
                    }
                }
            }
        };

        var Asset = function (cfg) {
            if (typeof cfg.assetConfig === 'string') {
                this.assetConfig = {
                    path: cfg.assetConfig
                };
            } else {
                this.assetConfig = cfg.assetConfig;
            }

            this.type = cfg.type;
            this.key = getStorageKey(this.assetConfig.path, cfg.manifest.profile);

            if (cfg.loadFromCache) {
                this.loadFromCache();
            }
        };

        Asset.prototype = {
            shouldCache: function() {
                return _storage &amp;&amp; this.assetConfig.update &amp;&amp; this.assetConfig.hash &amp;&amp; !this.assetConfig.remote;
            },

            is: function (asset) {
                return (!!asset &amp;&amp; this.assetConfig &amp;&amp; asset.assetConfig &amp;&amp; (this.assetConfig.hash === asset.assetConfig.hash))
            },

            cache: function(content) {
                if (this.shouldCache()) {
                    LocalStorage.setAsset(this.key, content || this.content);
                }
            },

            uncache: function() {
                LocalStorage.setAsset(this.key, null);
            },

            updateContent: function (content) {
                this.content = content;
            },

            getSize: function () {
                return this.content ? this.content.length : 0;
            },

            loadFromCache: function() {
                if (this.shouldCache()) {
                    this.content = LocalStorage.retrieveAsset(this.key);
                }
            }
        };

        var Manifest = function (cfg) {
            if (typeof cfg.content === &quot;string&quot;) {
                this.content = JSON.parse(cfg.content);
            } else {
                this.content = cfg.content;
            }
            this.assetMap = {};

            this.url = cfg.url;
            this.fromCache = !!cfg.cached;
            this.assetCache = !(cfg.assetCache === false);
            this.key = getStorageKey(this.url);

            // Pull out select properties for repetitive use
            this.profile = this.content.profile;
            this.hash = this.content.hash;
            this.loadOrder = this.content.loadOrder;
            this.deltas = this.content.cache ? this.content.cache.deltas : null;
            this.cacheEnabled = this.content.cache ? this.content.cache.enable : false;

            this.loadOrderMap = (this.loadOrder) ? Boot.createLoadOrderMap(this.loadOrder) : null;

            var tags = this.content.tags,
                platformTags = Ext.platformTags;

            if (tags) {
                if (tags instanceof Array) {
                    for (var i = 0; i &lt; tags.length; i++) {
                        platformTags[tags[i]] = true;
                    }
                } else {
                    Boot.apply(platformTags, tags);
                }

                // re-apply the query parameters, so that the params as specified
                // in the url always has highest priority
                Boot.apply(platformTags, Boot.loadPlatformsParam());
            }

            // Convert all assets into Assets
            this.js = this.processAssets(this.content.js, 'js');
            this.css = this.processAssets(this.content.css, 'css');
        };

        Manifest.prototype = {
            processAsset:  function(assetConfig, type) {
                var processedAsset = new Asset({
                    manifest: this,
                    assetConfig: assetConfig,
                    type: type,
                    loadFromCache: this.assetCache
                });
                this.assetMap[assetConfig.path] = processedAsset;
                return processedAsset;
            },

            processAssets: function(assets, type) {
                var results = [],
                    ln = assets.length,
                    i, assetConfig;

                for (i = 0; i &lt; ln; i++) {
                    assetConfig = assets[i];
                    results.push(this.processAsset(assetConfig, type));
                }

                return results;
            },

            useAppCache: function() {
                return true;
            },

            // Concatenate all assets for easy access
            getAssets: function () {
                return this.css.concat(this.js);
            },

            getAsset: function (path) {
                return this.assetMap[path];
            },

            shouldCache: function() {
                return this.hash &amp;&amp; this.cacheEnabled;
            },

            cache: function(content) {
                if (this.shouldCache()) {
                    LocalStorage.setAsset(this.key, JSON.stringify(content || this.content));
                }
                //&lt;debug&gt;
                else {
                    _debug(&quot;Manifest caching is disabled.&quot;);
                }
                //&lt;/debug&gt;
            },

            is: function(manifest) {
                //&lt;debug&gt;
                _debug(&quot;Testing Manifest: &quot; + this.hash + &quot; VS &quot; +  manifest.hash);
                //&lt;/debug&gt;
                return this.hash === manifest.hash;
            },

            // Clear the manifest from local storage
            uncache: function() {
                LocalStorage.setAsset(this.key, null);
            },

            exportContent: function() {
                return Boot.apply({
                    loadOrderMap: this.loadOrderMap
                }, this.content);
            }
        };

<span id='Ext-Microloader-property-_listeners'>        /**
</span>         * Microloader
         * @type {Array}
         * @private
         */
        var _listeners = [],
        _loaded = false,
        Microloader = {
            init: function () {
                Ext.microloaded = true;

                // data-app is in the dev template for an application and is also
                // injected into the app my CMD for production
                // We use this to prefix localStorage cache to prevent collisions
                var microloaderElement = document.getElementById('microloader');
                Microloader.appId = microloaderElement ? microloaderElement.getAttribute('data-app') : '';

                if (Ext.beforeLoad) {
                    postProcessor = Ext.beforeLoad(Ext.platformTags);
                }

                var readyHandler = Ext._beforereadyhandler;

                Ext._beforereadyhandler = function () {
                    if (Ext.Boot !== Boot) {
                        Ext.apply(Ext.Boot, Boot);
                        Ext.Boot = Boot;
                    }
                    if (readyHandler) {
                        readyHandler();
                    }
                };
            },

            applyCacheBuster: function(url) {
                var tstamp = new Date().getTime(),
                    sep = url.indexOf('?') === -1 ? '?' : '&amp;';
                url = url + sep + &quot;_dc=&quot; + tstamp;
                return url;
            },

            run: function() {
                Microloader.init();
                var manifest = Ext.manifest;

                if (typeof manifest === &quot;string&quot;) {
                    var extension = &quot;.json&quot;,
                        url = manifest.indexOf(extension) === manifest.length - extension.length
                            ? manifest
                            : manifest + &quot;.json&quot;,
                        key = getStorageKey(url),
                        content = LocalStorage.retrieveAsset(key);

                    // Manifest found in local storage, use this for immediate boot except in PhantomJS environments for building.
                    if (content) {
                        //&lt;debug&gt;
                            _debug(&quot;Manifest file, '&quot; + url + &quot;', was found in Local Storage&quot;);
                        //&lt;/debug&gt;
                        manifest = new Manifest({
                            url: url,
                            content: content,
                            cached: true
                        });
                        if (postProcessor) {
                            postProcessor(manifest);
                        }
                        Microloader.load(manifest);


                    // Manifest is not in local storage. Fetch it from the server
                    } else {
                        Boot.fetch(Microloader.applyCacheBuster(url), function (result) {
                            //&lt;debug&gt;
                                _debug(&quot;Manifest file was not found in Local Storage, loading: &quot; + url);
                            //&lt;/debug&gt;
                            manifest = new Manifest({
                                url: url,
                                content: result.content
                            });

                            manifest.cache();
                            if (postProcessor) {
                                postProcessor(manifest);
                            }
                            Microloader.load(manifest);
                        });
                    }

                // Embedded Manifest into JS file
                } else {
                    //&lt;debug&gt;
                        _debug(&quot;Manifest was embedded into application javascript file&quot;);
                    //&lt;/debug&gt;
                    manifest = new Manifest({
                        content: manifest
                    });
                    Microloader.load(manifest);
                }
            },

<span id='Ext-Microloader-method-load'>            /**
</span>             * @param {Manifest} manifest
             */
            load: function (manifest) {
                Microloader.urls = [];
                Microloader.manifest = manifest;
                Ext.manifest = Microloader.manifest.exportContent();

                var assets = manifest.getAssets(),
                    cachedAssets = [],
                    asset, i, len, include, entry;

                for (len = assets.length, i = 0; i &lt; len; i++) {
                    asset = assets[i];
                    include = Microloader.filterAsset(asset);
                    if (include) {
                        // Asset is using the localStorage caching system
                        if (manifest.shouldCache() &amp;&amp; asset.shouldCache()) {
                            // Asset already has content from localStorage, instantly seed that into boot
                            if (asset.content) {
                                //&lt;debug&gt;
                                    _debug(&quot;Asset: &quot; + asset.assetConfig.path + &quot; was found in local storage. No remote load for this file&quot;);
                                //&lt;/debug&gt;
                                entry = Boot.registerContent(asset.assetConfig.path, asset.type, asset.content);
                                if (entry.evaluated) {
                                    _warn(&quot;Asset: &quot; + asset.assetConfig.path + &quot; was evaluated prior to local storage being consulted.&quot;);
                                }
                            //load via AJAX and seed content into Boot
                            } else {
                                //&lt;debug&gt;
                                    _debug(&quot;Asset: &quot; + asset.assetConfig.path + &quot; was NOT found in local storage. Adding to load queue&quot;);
                                //&lt;/debug&gt;
                                cachedAssets.push(asset);
                            }
                        }
                        Microloader.urls.push(asset.assetConfig.path);
                        Boot.assetConfig[asset.assetConfig.path] = Boot.apply({type: asset.type}, asset.assetConfig);
                    }
                }

                // If any assets are using the caching system and do not have local versions load them first via AJAX
                if (cachedAssets.length &gt; 0) {
                    Microloader.remainingCachedAssets = cachedAssets.length;
                    while (cachedAssets.length &gt; 0) {
                        asset = cachedAssets.pop();
                        //&lt;debug&gt;
                            _debug(&quot;Preloading/Fetching Cached Assets from: &quot; + asset.assetConfig.path);
                        //&lt;/debug&gt;
                        Boot.fetch(asset.assetConfig.path, (function(asset) {
                            return function(result) {
                                Microloader.onCachedAssetLoaded(asset, result);
                            }
                        })(asset));
                    }
                } else {
                    Microloader.onCachedAssetsReady();
                }
            },

            // Load the asset and seed its content into Boot to be evaluated in sequence
            onCachedAssetLoaded: function (asset, result) {
                var checksum;
                result = Microloader.parseResult(result);
                Microloader.remainingCachedAssets--;

                if (!result.error) {
                    checksum = Microloader.checksum(result.content, asset.assetConfig.hash);
                    if (!checksum) {
                        _warn(&quot;Cached Asset '&quot; + asset.assetConfig.path + &quot;' has failed checksum. This asset will be uncached for future loading&quot;);

                        // Un cache this asset so it is loaded next time
                        asset.uncache();
                    }

                    //&lt;debug&gt;
                        _debug(&quot;Checksum for Cached Asset: &quot; + asset.assetConfig.path + &quot; is &quot; + checksum);
                    //&lt;/debug&gt;
                    Boot.registerContent(asset.assetConfig.path, asset.type, result.content);
                    asset.updateContent(result.content);
                    asset.cache();
                } else {
                    _warn(&quot;There was an error pre-loading the asset '&quot; + asset.assetConfig.path + &quot;'. This asset will be uncached for future loading&quot;);

                    // Un cache this asset so it is loaded next time
                    asset.uncache();
                }

                if (Microloader.remainingCachedAssets === 0) {
                    Microloader.onCachedAssetsReady();
                }
            },

            onCachedAssetsReady: function(){
                Boot.load({
                    url: Microloader.urls,
                    loadOrder: Microloader.manifest.loadOrder,
                    loadOrderMap: Microloader.manifest.loadOrderMap,
                    sequential: true,
                    success: Microloader.onAllAssetsReady,
                    failure: Microloader.onAllAssetsReady
                });
            },

            onAllAssetsReady: function() {
                _loaded = true;
                Microloader.notify();

                if (navigator.onLine !== false) {
                    //&lt;debug&gt;
                        _debug(&quot;Application is online, checking for updates&quot;);
                    //&lt;/debug&gt;
                    Microloader.checkAllUpdates();
                }
                else {
                    //&lt;debug&gt;
                        _debug(&quot;Application is offline, adding online listener to check for updates&quot;);
                    //&lt;/debug&gt;
                    if(window['addEventListener']) {
                        window.addEventListener('online', Microloader.checkAllUpdates, false);
                    }
                }
            },

            onMicroloaderReady: function (listener) {
                if (_loaded) {
                    listener();
                } else {
                    _listeners.push(listener);
                }
            },

<span id='Ext-Microloader-method-notify'>            /**
</span>             * @private
             */
            notify: function () {
                //&lt;debug&gt;
                    _debug(&quot;notifying microloader ready listeners.&quot;);
                //&lt;/debug&gt;
                var listener;
                while((listener = _listeners.shift())) {
                    listener();
                }
            },

            // Delta patches content
            patch: function (content, delta) {
                var output = [],
                    chunk, i, ln;

                if (delta.length === 0) {
                    return content;
                }

                for (i = 0,ln = delta.length; i &lt; ln; i++) {
                    chunk = delta[i];

                    if (typeof chunk === 'number') {
                        output.push(content.substring(chunk, chunk + delta[++i]));
                    }
                    else {
                        output.push(chunk);
                    }
                }

                return output.join('');
            },

            checkAllUpdates: function() {
                //&lt;debug&gt;
                    _debug(&quot;Checking for All Updates&quot;);
                //&lt;/debug&gt;
                if(window['removeEventListener']) {
                    window.removeEventListener('online', Microloader.checkAllUpdates, false);
                }

                if(_cache) {
                    Microloader.checkForAppCacheUpdate();
                }

                // Manifest came from a cached instance, check for updates
                if (Microloader.manifest.fromCache) {
                    Microloader.checkForUpdates();
                }
            },

            checkForAppCacheUpdate: function() {
                //&lt;debug&gt;
                    _debug(&quot;Checking App Cache status&quot;);
                //&lt;/debug&gt;
                if (_cache.status === _cache.UPDATEREADY || _cache.status === _cache.OBSOLETE) {
                    //&lt;debug&gt;
                        _debug(&quot;App Cache is already in an updated&quot;);
                    //&lt;/debug&gt;
                    Microloader.appCacheState = 'updated';
                } else if (_cache.status !== _cache.IDLE &amp;&amp; _cache.status !== _cache.UNCACHED) {
                    //&lt;debug&gt;
                        _debug(&quot;App Cache is checking or downloading updates, adding listeners&quot;);
                    //&lt;/debug&gt;
                    Microloader.appCacheState = 'checking';
                    _cache.addEventListener('error', Microloader.onAppCacheError);
                    _cache.addEventListener('noupdate', Microloader.onAppCacheNotUpdated);
                    _cache.addEventListener('cached', Microloader.onAppCacheNotUpdated);
                    _cache.addEventListener('updateready', Microloader.onAppCacheReady);
                    _cache.addEventListener('obsolete', Microloader.onAppCacheObsolete);
                } else {
                    //&lt;debug&gt;
                        _debug(&quot;App Cache is current or uncached&quot;);
                    //&lt;/debug&gt;
                    Microloader.appCacheState = 'current';
                }
            },

            checkForUpdates: function() {
                // Fetch the Latest Manifest from the server
                //&lt;debug&gt;
                    _debug(&quot;Checking for updates at: &quot; + Microloader.manifest.url);
                //&lt;/debug&gt;
                Boot.fetch(Microloader.applyCacheBuster(Microloader.manifest.url), Microloader.onUpdatedManifestLoaded);
            },

            onAppCacheError: function(e) {
                _warn(e.message);

                Microloader.appCacheState = 'error';
                Microloader.notifyUpdateReady();
            },

            onAppCacheReady: function() {
                _cache.swapCache();
                Microloader.appCacheUpdated();
            },

            onAppCacheObsolete: function() {
                Microloader.appCacheUpdated();
            },

            appCacheUpdated: function() {
                //&lt;debug&gt;
                    _debug(&quot;App Cache Updated&quot;);
                //&lt;/debug&gt;
                Microloader.appCacheState = 'updated';
                Microloader.notifyUpdateReady();
            },

            onAppCacheNotUpdated: function() {
                //&lt;debug&gt;
                    _debug(&quot;App Cache Not Updated Callback&quot;);
                //&lt;/debug&gt;
                Microloader.appCacheState = 'current';
                Microloader.notifyUpdateReady();
            },


            filterAsset: function(asset) {
                var cfg = (asset &amp;&amp; asset.assetConfig) || {};
                if(cfg.platform || cfg.exclude) {
                    return Boot.filterPlatform(cfg.platform, cfg.exclude);
                }
                return true;
            },

            onUpdatedManifestLoaded: function (result) {
                result = Microloader.parseResult(result);

                if (!result.error) {
                    var currentAssets, newAssets, currentAsset, newAsset, prop,
                        assets, deltas, deltaPath, include,
                        updatingAssets = [],
                        manifest = new Manifest({
                            url: Microloader.manifest.url,
                            content: result.content,
                            assetCache: false
                        });

                    Microloader.remainingUpdatingAssets = 0;
                    Microloader.updatedAssets = [];
                    Microloader.removedAssets = [];
                    Microloader.updatedManifest = null;
                    Microloader.updatedAssetsReady = false;

                    // If the updated manifest has turned off caching we need to clear out all local storage
                    // and trigger a appupdate as all content is now uncached
                    if (!manifest.shouldCache()) {
                        //&lt;debug&gt;
                        _debug(&quot;New Manifest has caching disabled, clearing out any private storage&quot;);
                        //&lt;/debug&gt;

                        Microloader.updatedManifest = manifest;
                        LocalStorage.clearAllPrivate(manifest);
                        Microloader.onAllUpdatedAssetsReady();
                        return;
                    }

                    // Manifest itself has changed
                    if (!Microloader.manifest.is(manifest)) {
                        Microloader.updatedManifest = manifest;

                        currentAssets = Microloader.manifest.getAssets();
                        newAssets = manifest.getAssets();

                        // Look through new assets for assets that do not exist or assets that have different versions
                        for (prop in newAssets) {
                            newAsset = newAssets[prop];
                            currentAsset = Microloader.manifest.getAsset(newAsset.assetConfig.path);
                            include = Microloader.filterAsset(newAsset);

                            if (include &amp;&amp; (!currentAsset || (newAsset.shouldCache() &amp;&amp; (!currentAsset.is(newAsset))))) {
                                //&lt;debug&gt;
                                    _debug(&quot;New/Updated Version of Asset: &quot; + newAsset.assetConfig.path + &quot; was found in new manifest&quot;);
                                //&lt;/debug&gt;
                                updatingAssets.push({_new: newAsset, _current: currentAsset});
                            }
                        }

                        // Look through current assets for stale/old assets that have been removed
                        for (prop in currentAssets) {
                            currentAsset = currentAssets[prop];
                            newAsset = manifest.getAsset(currentAsset.assetConfig.path);

                            //New version of this asset has been filtered out
                            include = !Microloader.filterAsset(newAsset);

                            if (!include || !newAsset || (currentAsset.shouldCache() &amp;&amp; !newAsset.shouldCache())) {
                                //&lt;debug&gt;
                                    _debug(&quot;Asset: &quot; + currentAsset.assetConfig.path + &quot; was not found in new manifest, has been filtered out or has been switched to not cache. Marked for removal&quot;);
                                //&lt;/debug&gt;
                                Microloader.removedAssets.push(currentAsset);
                            }
                        }

                        // Loop through all assets that need updating
                        if (updatingAssets.length &gt; 0) {
                            Microloader.remainingUpdatingAssets = updatingAssets.length;
                            while (updatingAssets.length &gt; 0) {
                                assets = updatingAssets.pop();
                                newAsset = assets._new;
                                currentAsset = assets._current;

                                // Full Updates will simply download the file and replace its current content
                                if (newAsset.assetConfig.update === &quot;full&quot; || !currentAsset) {

                                    //&lt;debug&gt;
                                    if (newAsset.assetConfig.update === &quot;delta&quot;) {
                                        _debug(&quot;Delta updated asset found without current asset available: &quot; + newAsset.assetConfig.path + &quot; fetching full file&quot;);
                                    } else {
                                        _debug(&quot;Full update found for: &quot; + newAsset.assetConfig.path + &quot; fetching&quot;);
                                    }
                                    //&lt;/debug&gt;

                                    // Load the asset and cache its  its content into Boot to be evaluated in sequence
                                    Boot.fetch(newAsset.assetConfig.path, (function (asset) {
                                            return function (result) {
                                                Microloader.onFullAssetUpdateLoaded(asset, result)
                                            };
                                        }(newAsset))
                                    );

                                    // Delta updates will be given a delta patch
                                } else if (newAsset.assetConfig.update === &quot;delta&quot;) {
                                    deltas = manifest.deltas;
                                    deltaPath = deltas + &quot;/&quot; + newAsset.assetConfig.path + &quot;/&quot; + currentAsset.assetConfig.hash + &quot;.json&quot;;
                                    // Fetch the Delta Patch and update the contents of the asset
                                    //&lt;debug&gt;
                                        _debug(&quot;Delta update found for: &quot; + newAsset.assetConfig.path + &quot; fetching&quot;);
                                    //&lt;/debug&gt;
                                    Boot.fetch(deltaPath,
                                        (function (asset, oldAsset) {
                                            return function (result) {
                                                Microloader.onDeltaAssetUpdateLoaded(asset, oldAsset, result)
                                            };
                                        }(newAsset, currentAsset))
                                    );
                                }
                            }
                        } else {
                            //&lt;debug&gt;
                                _debug(&quot;No Assets needed updating&quot;);
                            //&lt;/debug&gt;
                            Microloader.onAllUpdatedAssetsReady();
                        }
                    } else {
                        //&lt;debug&gt;
                            _debug(&quot;Manifest files have matching hash's&quot;);
                        //&lt;/debug&gt;
                        Microloader.onAllUpdatedAssetsReady();
                    }
                } else {
                    _warn(&quot;Error loading manifest file to check for updates&quot;);
                    Microloader.onAllUpdatedAssetsReady();
                }
            },

            onFullAssetUpdateLoaded: function(asset, result) {
                var checksum;
                result = Microloader.parseResult(result);
                Microloader.remainingUpdatingAssets--;

                if (!result.error) {
                    checksum = Microloader.checksum(result.content, asset.assetConfig.hash);
                    //&lt;debug&gt;
                        _debug(&quot;Checksum for Full asset: &quot; + asset.assetConfig.path + &quot; is &quot; + checksum);
                    //&lt;/debug&gt;
                    if (!checksum) {
                        //&lt;debug&gt;
                            _debug(&quot;Full Update Asset: &quot; + asset.assetConfig.path + &quot; has failed checksum. This asset will be uncached for future loading&quot;);
                        //&lt;/debug&gt;

                        // uncache this asset as there is a new version somewhere that has not been loaded.
                        asset.uncache();
                    } else {
                        asset.updateContent(result.content);
                        Microloader.updatedAssets.push(asset);
                    }
                } else {
                    //&lt;debug&gt;
                        _debug(&quot;Error loading file at&quot; + asset.assetConfig.path + &quot;. This asset will be uncached for future loading&quot;);
                    //&lt;/debug&gt;

                    // uncache this asset as there is a new version somewhere that has not been loaded.
                    asset.uncache();
                }

                if (Microloader.remainingUpdatingAssets === 0) {
                        Microloader.onAllUpdatedAssetsReady();
                }
            },

            onDeltaAssetUpdateLoaded: function(asset, oldAsset, result) {
                var json, checksum, content;
                result = Microloader.parseResult(result);
                Microloader.remainingUpdatingAssets--;

                if (!result.error) {
                    //&lt;debug&gt;
                        _debug(&quot;Delta patch loaded successfully, patching content&quot;);
                    //&lt;/debug&gt;
                    try {
                        json = JSON.parse(result.content);
                        content = Microloader.patch(oldAsset.content, json);
                        checksum = Microloader.checksum(content, asset.assetConfig.hash);
                        //&lt;debug&gt;
                            _debug(&quot;Checksum for Delta Patched asset: &quot; + asset.assetConfig.path + &quot; is &quot; + checksum);
                        //&lt;/debug&gt;
                        if (!checksum) {
                            //&lt;debug&gt;
                                _debug(&quot;Delta Update Asset: &quot; + asset.assetConfig.path + &quot; has failed checksum. This asset will be uncached for future loading&quot;);
                            //&lt;/debug&gt;

                            // uncache this asset as there is a new version somewhere that has not been loaded.
                            asset.uncache();
                        } else {
                            asset.updateContent(content);
                            Microloader.updatedAssets.push(asset);
                        }
                    } catch (e) {
                        _warn(&quot;Error parsing delta patch for &quot; + asset.assetConfig.path + &quot; with hash &quot; + oldAsset.assetConfig.hash + &quot; . This asset will be uncached for future loading&quot;);
                        // uncache this asset as there is a new version somewhere that has not been loaded.
                        asset.uncache();
                    }
                } else {
                    _warn(&quot;Error loading delta patch for &quot; + asset.assetConfig.path + &quot; with hash &quot; + oldAsset.assetConfig.hash + &quot; . This asset will be uncached for future loading&quot;);

                    // uncache this asset as there is a new version somewhere that has not been loaded.
                    asset.uncache();
                }
                if (Microloader.remainingUpdatingAssets === 0) {
                    Microloader.onAllUpdatedAssetsReady();
                }
            },

            //TODO: Make this all transaction based to allow for reverting if quota is exceeded
            onAllUpdatedAssetsReady: function() {
                var asset;
                Microloader.updatedAssetsReady = true;

                if (Microloader.updatedManifest) {
                    while (Microloader.removedAssets.length &gt; 0) {
                        asset = Microloader.removedAssets.pop();
                        //&lt;debug&gt;
                            _debug(&quot;Asset: &quot; + asset.assetConfig.path + &quot; was removed, un-caching&quot;);
                        //&lt;/debug&gt;
                        asset.uncache();
                    }

                    if (Microloader.updatedManifest) {
                        //&lt;debug&gt;
                        _debug(&quot;Manifest was updated, re-caching&quot;);
                        //&lt;/debug&gt;
                        Microloader.updatedManifest.cache();
                    }

                    while (Microloader.updatedAssets.length &gt; 0) {
                        asset = Microloader.updatedAssets.pop();
                        //&lt;debug&gt;
                            _debug(&quot;Asset: &quot; + asset.assetConfig.path + &quot; was updated, re-caching&quot;);
                        //&lt;/debug&gt;
                        asset.cache();
                    }

                }

                Microloader.notifyUpdateReady();
            },

            notifyUpdateReady: function () {
                if (Microloader.appCacheState !== 'checking' &amp;&amp; Microloader.updatedAssetsReady) {
                    if (Microloader.appCacheState === 'updated' || Microloader.updatedManifest) {
                        //&lt;debug&gt;
                            _debug(&quot;There was an update here you will want to reload the app, trigger an event&quot;);
                        //&lt;/debug&gt;
                        Microloader.appUpdate = {
                            updated: true,
                            app: Microloader.appCacheState === 'updated',
                            manifest: Microloader.updatedManifest &amp;&amp; Microloader.updatedManifest.exportContent()
                        };

                        Microloader.fireAppUpdate();
                    }
                    //&lt;debug&gt;
                    else {
                        _debug(&quot;AppCache and LocalStorage Cache are current, no updating needed&quot;);
                        Microloader.appUpdate = {};
                    }
                    //&lt;/debug&gt;
                }
            },

            fireAppUpdate: function() {
                if (Ext.GlobalEvents) {
                    // We defer dispatching this event slightly in order to let the application finish loading
                    // as we are still very early in the lifecycle
                    Ext.defer(function() {
                        Ext.GlobalEvents.fireEvent('appupdate', Microloader.appUpdate);
                    }, 100);
                }
            },

            checksum: function(content, hash) {
                if(!content || !hash) {
                    return false;
                }

                var passed = true,
                    hashLn = hash.length,
                    checksumType = content.substring(0, 1);

                if (checksumType == '/') {
                    if (content.substring(2, hashLn + 2) !== hash) {
                        passed = false;
                    }
                } else if (checksumType == 'f') {
                    if (content.substring(10, hashLn + 10) !== hash) {
                        passed = false;
                    }
                } else if (checksumType == '.') {
                    if (content.substring(1, hashLn + 1) !== hash) {
                        passed = false;
                    }
                }
                return passed;
            },
            parseResult: function(result) {
                var rst = {};
                if ((result.exception || result.status === 0) &amp;&amp; !Boot.env.phantom) {
                    rst.error = true;
                } else if ((result.status &gt;= 200 &amp;&amp; result.status &lt; 300) || result.status === 304
                    || Boot.env.phantom
                    || (result.status === 0 &amp;&amp; result.content.length &gt; 0)
                ) {
                    rst.content = result.content;
                } else {
                    rst.error = true;
                }
                return rst;
            }
        };

    return Microloader;
}());

<span id='Ext-Microloader-property-manifest'>/**
</span> * @type {String/Object}
 */
Ext.manifest = Ext.manifest || &quot;bootstrap&quot;;

Ext.Microloader.run();</pre>
</body>
</html>
